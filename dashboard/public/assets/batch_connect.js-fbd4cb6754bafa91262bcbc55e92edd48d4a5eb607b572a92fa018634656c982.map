{
  "version": 3,
  "sources": ["../../javascript/packs/batch_connect.js"],
  "sourcesContent": ["'use strict';\n\nconst bcPrefix = 'batch_connect_session_context';\nconst shortNameRex = new RegExp(`${bcPrefix}_([\\\\w\\\\-]+)`);\nconst tokenRex = /([A-Z][a-z]+){1}([\\w\\-]+)/;\n\n// @example ['NodeType', 'Cluster']\nconst formTokens = [];\n\n// simple lookup table to indicate that the change handler is setup between two\n// elements. I.e., {'cluster': [ 'node_type' ] } means that changes to cluster\n// trigger changes to node_type\nconst optionForHandlerCache = {};\n\n\n// simples array of string ids for elements that have a handler\nconst minMaxHandlerCache = [];\nconst setHandlerCache = [];\n// hide handler cache is a map in the form '{ from: [hideThing1, hideThing2] }'\nconst hideHandlerCache = {};\n\n// Lookup tables for setting min & max values\n// for different directives.\nconst minMaxLookup = {};\nconst setValueLookup = {};\nconst hideLookup = {};\n\n// the regular expression for mountain casing\nconst mcRex = /[-_]([a-z])|([_-][0-9])|([\\/])/g;\n\n// whether we're still initializing or not\nlet initializing = true;\n\nfunction bcElement(name) {\n  return `${bcPrefix}_${name.toLowerCase()}`;\n};\n\n// here the simple name for 'batch_connect_session_context_cluster'\n// is just 'cluster'.\nfunction shortId(elementId) {\n  const match = elementId.match(shortNameRex);\n\n  if (match.length >= 1) {\n    return match[1];\n  } else {\n    return '';\n  };\n};\n\n/**\n * Mountain case the words from a string, by tokenizing on [-_].  In the\n * simplest case it just capitalizes.\n *\n * There is a special case where seperators are followed numbers. In this case\n * The seperator is kept as a hyphen because that's how jQuery expects it.\n *\n * @param      {string}  str     The word string to mountain case\n *\n * @example  given 'foo' this returns 'Foo'\n * @example  given 'foo-bar' this returns 'FooBar'\n * @example  given 'physics_1234' this returns 'Physics-1234'\n */\n// Convert dashed to camelCase\nfunction mountainCaseWords(str) {\n  const lower = str.toLowerCase();\n  const first = lower.charAt(0).toUpperCase();\n  const rest = lower.slice(1).replace(mcRex, function(_all, letter, prefixedNumber, slash) {\n    if(letter){\n      return letter.toUpperCase();\n    }else if(prefixedNumber){\n      return prefixedNumber.replace('_','-');\n    }else if(slash){\n      return '_';\n    }\n  });\n\n  return  `${first}${rest}`;\n}\n\n/**\n * Format passed string to snake_case. All characters become lowercase. Existing\n * underscores are unchanged and dashes become underscores. Underscores are added \n * before locations where an uppercase character is followed by a lowercase character.\n *\n * @param      {string}  str     The word string to snake case\n *\n * @example  given 'MountainCase' this returns 'mountain_case'\n * @example  given 'camelCase' this returns 'camel_case'\n * @example  given 'OSC_JUPYTER' this returns 'osc_jupyter'\n */\nfunction snakeCaseWords(str) {\n  if(str === undefined) return undefined;\n\n  let snakeCase = \"\";\n\n  str.split('').forEach((c, index) => {\n    if(c === '-' || c === '_') {\n      snakeCase += '_';\n    } else if (index == 0) {\n      snakeCase += c.toLowerCase();\n    } else if(c == c.toUpperCase() && isNaN(c)) {\n      const nextIsUpper = (index + 1 !== str.length) ? str[index + 1] === str[index + 1].toUpperCase() : true;\n      if (str[index-1] === '_' || nextIsUpper) {\n        snakeCase += c.toLowerCase();\n      } else {\n        snakeCase += `_${c.toLowerCase()}`;\n      }\n    } else {\n      snakeCase += c;\n    }\n  });\n\n  return snakeCase;\n}\n\n/**\n *\n * @param {Array} elements\n */\nfunction memorizeElements(elements) {\n  elements.each((_i, ele) => {\n    formTokens.push(mountainCaseWords(shortId(ele['id'])));\n    optionForHandlerCache[ele['id']] = [];\n  });\n};\n\nfunction makeChangeHandlers(){\n  const allElements = $(`[id^=${bcPrefix}]`);\n  memorizeElements(allElements);\n\n  allElements.each((_i, element) => {\n    if (element['type'] == \"select-one\"){\n      let optionSearch = `#${element['id']} option`;\n      let options = $(optionSearch);\n      options.each((_i, opt) => {\n          // the variable 'opt' is just a data structure, not a jQuery result. \n          // it has no attr, data, show or hide methods so we have to query\n          // for it again\n          let data = $(`${optionSearch}[value='${opt.value}']`).data();\n          let keys = Object.keys(data);\n          if(keys.length !== 0) {\n            keys.forEach((key) => {\n              if(key.startsWith('optionFor')) {\n                let token = key.replace(/^optionFor/,'');\n                addOptionForHandler(idFromToken(token), element['id']);\n              } else if(key.startsWith('max') || key.startsWith('min')) {\n                addMinMaxForHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('set')) {\n                addSetHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('hide')) {\n                addHideHandler(element['id'], opt.value, key, data[key]);\n              }\n            });\n          }\n      });\n    }\n  });\n};\n\nfunction addHideHandler(optionId, option, key,  configValue) {\n  const changeId = idFromToken(key.replace(/^hide/,''));\n\n  if(hideLookup[optionId] === undefined) hideLookup[optionId] = new Table(changeId, 'option_value');\n  const table = hideLookup[optionId];\n  table.put(changeId, option, configValue);\n\n  if(hideHandlerCache[optionId] === undefined) hideHandlerCache[optionId] = [];\n\n  if(!hideHandlerCache[optionId].includes(changeId)) {\n    const changeElement = $(`#${optionId}`);\n\n    changeElement.on('change', (event) => {\n      updateVisibility(event, changeId);\n    });\n\n    hideHandlerCache[optionId].push(changeId);\n  }\n\n  updateVisibility({ target: document.querySelector(`#${optionId}`) }, changeId);\n}\n\n/**\n *\n * @param {*} subjectId batch_connect_session_context_node_type\n * @param {*} option gpu\n * @param {*} key maxNumCoresForClusterAnnieOakley\n * @param {*} configValue 42\n *\n * node_type:\n *   widget: select\n *   options:\n *    - [\n *        'gpu',\n *        data-max-num-cores-for-cluster-annie-oakley: 42\n *      ]\n */\nfunction addMinMaxForHandler(subjectId, option, key,  configValue) {\n  subjectId = String(subjectId || '');\n  configValue = parseInt(configValue);\n\n  const configObj = parseMinMaxFor(key);\n  const objectId = configObj['subjectId'];\n  // this is the id of the target object we're setting the min/max for.\n  // if it's undefined - there's nothing to do, it was likely configured wrong.\n  if(objectId === undefined) return;\n\n  const secondDimId = configObj['predicateId'];\n  const secondDimValue = configObj['predicateValue'];\n\n  // several subjects can try to change the object, so the table lookup key has to have both\n  const lookupKey = `${subjectId}_${objectId}`;\n  if(minMaxLookup[lookupKey] === undefined) minMaxLookup[lookupKey] = new Table(subjectId, secondDimId);\n  const table = minMaxLookup[lookupKey];\n  table.put(option, secondDimValue, {[minOrMax(key)] : configValue });\n\n  let cacheKey = `${objectId}_${subjectId}_${secondDimId}`;\n  if(!minMaxHandlerCache.includes(cacheKey)) {\n    const changeElement = $(`#${subjectId}`);\n\n    changeElement.on('change', (event) => {\n      toggleMinMax(event, objectId, secondDimId);\n    });\n\n    minMaxHandlerCache.push(cacheKey);\n  }\n\n  cacheKey = `${objectId}_${secondDimId}_${subjectId}`;\n  if(secondDimId !== undefined && !minMaxHandlerCache.includes(cacheKey)){\n    const secondEle = $(`#${secondDimId}`);\n\n    secondEle.on('change', (event) => {\n      toggleMinMax(event, objectId, subjectId);\n    });\n\n    minMaxHandlerCache.push(cacheKey);\n  }\n\n  toggleMinMax({ target: document.querySelector(`#${subjectId}`) }, objectId, secondDimId);\n}\n\n/**\n *\n * @param {*} optionId batch_connect_session_context_classroom\n * @param {*} option 'PHY_9000'\n * @param {*} key setAccount\n * @param {*} configValue 'phy3005'\n *\n * classroom:\n *   widget: select\n *   options:\n *    - [\n *        'Physics Maximum', 'PHY_9000',\n *        data-set-account: 'phy3005'\n *      ]\n */\nfunction addSetHandler(optionId, option, key,  configValue) {\n  const k = key.replace(/^set/,'');\n  const id = String(idFromToken(k));\n  if(id === 'undefined') return;\n\n  // id is account. optionId is classroom\n  let cacheKey = `${id}_${optionId}`\n  if(setValueLookup[cacheKey] === undefined) setValueLookup[cacheKey] = new Table(optionId, undefined);\n  const table = setValueLookup[cacheKey];\n  table.put(option, undefined, configValue);\n\n  if(!setHandlerCache.includes(cacheKey)) {\n    const changeElement = $(`#${optionId}`);\n\n    changeElement.on('change', (event) => {\n      setValue(event, id);\n    });\n\n    setHandlerCache.push(cacheKey);\n  }\n\n  setValue({ target: document.querySelector(`#${optionId}`) }, id);\n}\n\nfunction setValue(event, changeId) {\n  const chosenVal = event.target.value;\n  const cacheKey = `${changeId}_${event.target['id']}`\n  const table = setValueLookup[cacheKey];\n  if (table === undefined) return;\n\n  const changeVal = table.get(chosenVal, undefined);\n\n  if(changeVal !== undefined) {\n    const innerElement = $(`#${changeId}`);\n    innerElement.attr('value', changeVal);\n    innerElement.val(changeVal);\n  }\n}\n\n/**\n *\n *  This is a simple table class to describe the relationship between\n *  two different element types as a table with named columns.\n *\n *  table.get('gpu','owens') would return the value shown.\n *\n *      'oakley'   |                    |                |\n *      'owens'    | { min: 3, max: 42} |                |\n *                 |  'gpu'             |   'hugemem'    |\n *\n * In the simple case, it's a 1d vector instead of a 2d matrix. This\n * allows for, say, gpu to have the same min & max across clusters.\n */\nclass Table {\n  constructor(x, y) {\n    // FIXME: probably need to make Vector class? Wouldn't want to add a flag to the constructor.\n    // we don't use x or y internally, though x is used externally.\n    this.x = x;\n    this.xIdxLookup = {};\n\n    this.y = y;\n    this.yIdxLookup = {};\n    this.table = y === undefined ? [] : [[]];\n  }\n\n  put(x, y, value) {\n    if(!x) return;\n    x = snakeCaseWords(x);\n    y = snakeCaseWords(y);\n\n    if(this.xIdxLookup[x] === undefined) this.xIdxLookup[x] = Object.keys(this.xIdxLookup).length;\n    if(y && this.yIdxLookup[y] === undefined) this.yIdxLookup[y] = Object.keys(this.yIdxLookup).length;\n\n    const xIdx = this.xIdxLookup[x];\n    const yIdx = this.yIdxLookup[y];\n\n    if(this.table[xIdx] === undefined ){\n      this.table[xIdx] = y === undefined ? undefined : [];\n    }\n\n    // if y's index is defined, then it's a 2d matrix. Otherwise a 1d vector.\n    if(yIdx === undefined) {\n      if(this.table[xIdx] === undefined){\n        this.table[xIdx] = value;\n      } else {\n        const prev = this.table[xIdx];\n        const newer = value;\n        if(typeof newer == 'string' && typeof prev == 'string'){\n          this.table[xIdx] = newer;\n        } else {\n          this.table[xIdx] = Object.assign(prev, newer);\n        }\n      }\n    } else {\n      if(this.table[xIdx][yIdx] === undefined){\n        this.table[xIdx][yIdx] = value;\n      } else {\n        const prev = this.table[xIdx][yIdx];\n        const newer = value;\n        if(typeof newer == 'string' && typeof prev == 'string'){\n          this.table[xIdx][yIdx] = newer;\n        } else {\n          this.table[xIdx][yIdx] = Object.assign(prev, newer);\n        }\n      }\n    }\n  }\n\n  get(x, y) {\n    const xIdx = this.xIdxLookup[snakeCaseWords(x)];\n    const yIdx = this.yIdxLookup[snakeCaseWords(y)];\n\n    if(this.table[xIdx] === undefined){\n      return undefined;\n    }else if(y === undefined){\n      return this.table[xIdx];\n    }else {\n      return this.table[xIdx][yIdx];\n    }\n  }\n}\n\n/**\n * Update the visibility of `changeId` based on the\n * event and what's in the hideLookup table.\n */\nfunction updateVisibility(event, changeId) {\n  const val = event.target.value;\n  const id = event.target['id'];\n  let changeElement = undefined;\n  $(`#${changeId}`).parents().each(function(_i, parent) {\n    if(parent.classList.contains('form-group')) {\n      changeElement = $(parent);\n      return false;\n    }\n  });\n\n  if (changeElement === undefined || changeElement.length <= 0) return;\n\n  // safe to access directly?\n  const hide = hideLookup[id].get(changeId, val);\n  if(hide === undefined && !initializing) {\n    changeElement.show();\n  }else if(hide === true) {\n    changeElement.hide();\n  }\n}\n\n/**\n * Update the min & max values of `changeId` based on the\n * event, the `otherId` and the settings in minMaxLookup table.\n */\nfunction toggleMinMax(event, changeId, otherId) {\n  let x = undefined, y = undefined;\n\n  // many subjects can change the object, so we have to find the correct table\n  // in the form <subject>_<object>\n  let lookupKey = `${event.target['id']}_${changeId}`;\n  if(minMaxLookup[lookupKey] === undefined) {\n    lookupKey = `${otherId}_${changeId}`;\n  }\n\n  const table = minMaxLookup[lookupKey];\n\n  // in the example of cluster & node_type, either element can trigger a change\n  // so let's figure out the axis' based on the change element's id.\n  if(event.target['id'] == table.x) {\n    x = snakeCaseWords(event.target.value);\n    y = snakeCaseWords($(`#${otherId}`).val());\n  } else {\n    y = snakeCaseWords(event.target.value);\n    x = snakeCaseWords($(`#${otherId}`).val());\n  }\n\n  const changeElement = $(`#${changeId}`);\n  const mm = table.get(x, y);\n  const prev = {\n    min: parseInt(changeElement.attr('min')),\n    max: parseInt(changeElement.attr('max')),\n  };\n\n  [ 'max', 'min' ].forEach((dim) => {\n    if(mm && mm[dim] !== undefined) {\n      changeElement.attr(dim, mm[dim]);\n    }\n  });\n\n  const val = clamp(parseInt(changeElement.val()), prev, mm)\n  if (val !== undefined) {\n    changeElement.attr('value', val);\n    changeElement.val(val);\n  }\n}\n\nfunction clamp(currentValue, previous, next) {\n  if(next === undefined){\n    return undefined;\n\n  // you've set the boundary, so when you go to the next value - keep it at the next's boundary\n  } else if(currentValue === previous['min']) {\n    return next['min'];\n  } else if(currentValue === previous['max']) {\n    return next['max'];\n\n  // otherwise you could be up or down shifting to fit within the next's boundaries\n  } else if(currentValue <= next['min']) {\n    return next['min'];\n  } else if(currentValue >= next['max']) {\n    return next['max'];\n  } else {\n    return undefined;\n  }\n}\n\nfunction addOptionForHandler(causeId, targetId) {\n  const changeId = String(causeId || '');\n\n  if(changeId.length == 0 || optionForHandlerCache[causeId].includes(targetId)) {\n    // nothing to do. invalid causeId or we already have a handler between the 2\n    return;\n  }\n\n  let causeElement = $(`#${causeId}`);\n\n  if(targetId && causeElement) {\n    // cache the fact that there's a new handler here\n    optionForHandlerCache[causeId].push(targetId);\n\n    causeElement.on('change', (event) => {\n      toggleOptionsFor(event, targetId);\n    });\n\n    // fake an event to initialize\n    toggleOptionsFor({ target: document.querySelector(`#${causeId}`) }, targetId);\n  }\n};\n\n/**\n *\n * @param {*} key minNumCoresForClusterAnnieOakley\n * @returns\n *\n *  {\n *    'subjectId': 'batch_connect_session_context_num_cores',\n *    'predicateId': 'batch_connect_session_context_cluster',\n *    'predicateValue': 'annie_oakley'\n *  }\n */\nfunction parseMinMaxFor(key) {\n  let k = undefined;\n  let predicateId = undefined;\n  let predicateValue = undefined;\n  let subjectId = undefined;\n\n  if(key.startsWith('min')) {\n    k = key.replace(/^min/,'');\n  } else if(key.startsWith('max')) {\n    k = key.replace(/^max/, '')\n  }\n\n  //trying to parse maxNumCoresForClusterOwens\n  const tokens = k.match(/^(\\w+)For(\\w+)$/);\n\n  if(tokens == null) {\n    // the key is likely just maxNumCores with no For clause\n    subjectId = idFromToken(k);\n\n  } else if(tokens.length == 3) {\n    const subject = tokens[1];\n    const predicateFull = tokens[2];\n    subjectId = idFromToken(subject);\n\n    const predicateTokens = predicateFull.split(/(?=[A-Z])/);\n    if(predicateTokens && predicateTokens.length >= 2) {\n\n      // if there are only 2 tokens then it's like 'ClusterOwens' which is easy\n      if(predicateTokens.length == 2) {\n        predicateId = idFromToken(predicateTokens[0]);\n        predicateValue = predicateTokens[1];\n\n      // else it's like NodeTypeFooBar, so it's a little more difficult\n      } else {\n        let tokenString = '';\n        let done = false;\n        predicateTokens.forEach((pt, idx) => {\n          if(done) { return; }\n\n          tokenString = `${tokenString}${pt}`\n          let tokenId = idFromToken(tokenString);\n          if(tokenId !== undefined) {\n            done = true;\n            predicateId = tokenId;\n            predicateValue = predicateTokens.slice(idx+1).join('');\n          }\n        })\n      }\n    }\n  }\n\n  return {\n    'subjectId': subjectId,\n    'predicateId': predicateId,\n    'predicateValue': snakeCaseWords(predicateValue),\n  }\n}\n\nfunction minOrMax(key) {\n  if(key.startsWith('min')){\n    return 'min';\n  } else if(key.startsWith('max')){\n    return 'max';\n  } else {\n    return null;\n  }\n}\n\n/**\n * Turn a MountainCase token into a form element id\n *\n * @example\n *  NodeType -> batch_connect_session_context_node_type\n *\n * @param {*} str\n * @returns\n */\nfunction idFromToken(str) {\n  elements = formTokens.map((token) => {\n    let match = str.match(`^${token}{1}`);\n\n    if (match && match.length >= 1) {\n      let ele = snakeCaseWords(match[0]);\n      return bcElement(ele);\n    }\n  }).filter((id) => {\n    return id !== undefined;\n  });\n\n  if(elements.length == 0) {\n    return undefined;\n  }else if(elements.length == 1) {\n    return elements[0];\n\n  // you matched multiple things. For example you're searching for\n  // ClusterFilesystem and matched against both 'Cluster' and 'ClusterFilesystem'.\n  // The correrct element id ends with cluster_filesystem.\n  } else if(elements.length > 1) {\n    const snake_case_str = snakeCaseWords(str);\n    return elements.filter((element) => {\n      return element.endsWith(snake_case_str);\n    })[0];\n  }\n}\n\n\n/**\n * Extract the option for out of an option for directive.\n *\n * @example\n *  optionForClusterOakley -> Cluster\n *\n * @param {*} str\n * @returns - the option for string\n */\nfunction optionForFromToken(str) {\n  return formTokens.map((token) => {\n    let match = str.match(`^optionFor${token}`);\n\n    if (match && match.length >= 1) {\n      return token;\n    }\n  }).filter((id) => {\n    return id !== undefined;\n  })[0];\n}\n\n/**\n * Hide or show options of an element based on which cluster is\n * currently selected and the data-option-for-CLUSTER attributes\n * for each option\n *\n * @param      {string}  element_name  The name of the element with options to toggle\n */\n function toggleOptionsFor(_event, elementId) {\n  const options = $(`#${elementId} option`);\n  let hideSelectedValue = undefined;\n\n  options.each(function(_i, option) {\n    // the variable 'option' is just a data structure. it has no attr, data, show\n    // or hide methods so we have to query for it again\n    let optionElement = exactlyOneOption(elementId, option);\n    let data = optionElement.data();\n    let hide = false;\n\n    // even though an event occured - an option may be hidden based on the value of\n    // something else entirely. We're going to hide this option if _any_ of the\n    // option-for- directives apply.\n    for (const [key, _value] of Object.entries(data)) {\n\n      let optionFor = optionForFromToken(key);\n      let optionForId = idFromToken(key.replace(/^optionFor/,''));\n\n      // it's some other directive type, so just keep going and/or not real\n      if(!key.startsWith('optionFor') || optionForId === undefined) {\n        continue;\n      }\n\n      let optionForValue =  mountainCaseWords($(`#${optionForId}`)[0].value);\n\n      hide = data[`optionFor${optionFor}${optionForValue}`] === false;\n      if(hide === true) {\n        break;\n      }\n    }\n\n    if(hide) {\n      optionElement.hide();\n      optionElement.prop('disabled', true);\n\n      if(optionElement.prop('selected')) {\n        optionElement.prop('selected', false);\n        hideSelectedValue = optionElement.text();\n      }\n    } else {\n      optionElement.show();\n      optionElement.prop('disabled', false);\n    }\n  });\n\n  // now that we've hidden/shown everything, let's choose what should now\n  // be the current selected value.\n  // if you've hidden what _was_ selected.\n  if(hideSelectedValue !== undefined) {\n    let others = $(`#${elementId} option[value='${hideSelectedValue}']`);\n    let newSelectedOption = undefined;\n\n    // You have hidden what _was_ selected, so try to find a duplicate option that is visible\n    if(others.length > 1) {\n      others.each((_i, ele) => {\n        if(ele.style['display'] === '') {\n          newSelectedOption = exactlyOneOption(elementId, ele);\n          return;\n        }\n      });\n    }\n\n    // no duplciates are visible, so just pick the first visible option\n    if(newSelectedOption === undefined) {\n      others = $(`#${elementId} option`)\n      others.each((_i, ele) => {\n        if(newSelectedOption === undefined && ele.style['display'] === '') {\n          newSelectedOption = exactlyOneOption(elementId, ele);\n        }\n      });\n    }\n\n    if(newSelectedOption !== undefined) {\n      newSelectedOption.prop('selected', true);\n    }\n  }\n\n  // now that we're done, propogate this change to data-set or data-hide handlers\n  $(`#${elementId}`).trigger('change');\n};\n\n// Return exactly 1 jquery object for this id's option\nfunction exactlyOneOption(id, option) {\n  let optionElement = $(`#${id} option[value='${option.value}']`);\n\n  if(optionElement.length > 1) {\n    optionElement.each((_i, ele) => {\n      if(option.attributes == ele.attributes){\n        optionElement = $(ele);\n        return;\n      }\n    });\n  }\n\n  return optionElement;\n}\n\n// simple function to sanitize css query strings\nfunction sanitizeQuery(item) {\n  return item.replaceAll('.', '\\\\.');\n}\n\n\nfunction optionForEvent(target) {\n  let simpleName = shortId(target['id']);\n  return mountainCaseWords(simpleName);\n};\n\njQuery(function() {\n  makeChangeHandlers();\n  initializing = false;\n});\n"],
  "mappings": "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",
  "names": ["bcPrefix", "shortNameRex", "formTokens", "optionForHandlerCache", "minMaxHandlerCache", "setHandlerCache", "hideHandlerCache", "minMaxLookup", "setValueLookup", "hideLookup", "mcRex", "initializing", "bcElement", "name", "bcPrefix", "shortId", "elementId", "match", "shortNameRex", "mountainCaseWords", "str", "lower", "first", "rest", "_all", "letter", "prefixedNumber", "slash", "snakeCaseWords", "snakeCase", "c", "index", "nextIsUpper", "memorizeElements", "elements", "_i", "ele", "makeChangeHandlers", "allElements", "element", "optionSearch", "opt", "data", "keys", "key", "token", "addOptionForHandler", "idFromToken", "addMinMaxForHandler", "addSetHandler", "addHideHandler", "optionId", "option", "configValue", "changeId", "Table", "event", "updateVisibility", "subjectId", "configObj", "parseMinMaxFor", "objectId", "secondDimId", "secondDimValue", "lookupKey", "minOrMax", "cacheKey", "toggleMinMax", "k", "id", "setValue", "chosenVal", "table", "changeVal", "innerElement", "x", "y", "value", "xIdx", "yIdx", "prev", "newer", "val", "changeElement", "parent", "hide", "otherId", "mm", "dim", "clamp", "currentValue", "previous", "next", "causeId", "targetId", "causeElement", "toggleOptionsFor", "predicateId", "predicateValue", "tokens", "subject", "predicateFull", "predicateTokens", "tokenString", "done", "pt", "idx", "tokenId", "snake_case_str", "optionForFromToken", "_event", "options", "hideSelectedValue", "optionElement", "exactlyOneOption", "_value", "optionFor", "optionForId", "optionForValue", "others", "newSelectedOption", "makeChangeHandlers", "initializing"]
}
